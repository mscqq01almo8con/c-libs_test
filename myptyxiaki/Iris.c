/*Οδηγίες προεπεξεργαστή για ενσωμάτωση αρχείων επικεφαλίδων*/
#include<math.h>
#include<stdio.h>
#include<stdlib.h>
#include<string.h>
/*This software uses the gnuplot_i library written by N.Devillard <ndevilla@free.fr>*/
#include"gnuplot_i.h"
/*Συνάρτηση εισόδου τιμών από γραμμή εντολών*/
int input(int*num_temp,int*steps,int bond[][10],int distance[][150],int lattice[][5],double*average,double*local_length,double temperature[])
{
 FILE*datafile=NULL/*Ορισμός αρχείου*/;
 int i,j,k,l,m,n/*Μετρητές*/,nearest[22500][3]/*Πίνακας τετραγώνων αποστάσεων και σημείων δεδομένων που τα ορίζουν*/,neighbor[150][5]/*Πίνακας πέντε πλησιέστερων γειτόνων σημείων δεδομένων*/;
 double final_temp/*Τελική θερμοκρασία*/,step_temp/*Βήμα θερμοκρασίας*/;

 /*Άνοιγμα αρχείου*/
 datafile=fopen("Iris.dat","r");
 /*Έλεγχος έγκυρου ανοίγματος αρχείου*/
 if(!datafile)
 {
  printf("Σφάλμα ανοίγοντας το αρχείο %s","Iris.dat");
  return 1;
 }
 /*Ορισμός αρχικής θέσης στην αρχή του αρχείου*/
 rewind(datafile);
 /*Είσοδος Monte Carlo βημάτων(M.C.S.)*/
 printf("Monte Carlo βήματα:");
 scanf("%d",steps);
 /*Αρχικοποίηση τιμής κατάστασης Potts όλων των σημείων δεδομένων με μηδέν*/
 for(i=0;i<150;i++)
 {
  lattice[i][0]=0;
 }
 /*Ανάγνωση σημείων δεδομένων από το αρχείο Iris.dat και καταγραφή τετραδιάστατων συντεταγμένων τους*/
 i=0;
 while(fscanf(datafile,"%d,%d,%d,%d,%*s",&lattice[i][1],&lattice[i][2],&lattice[i][3],&lattice[i][4])!=EOF)
 {
  /*Έλεγχος έγκυρης ανάγνωσης αρχείου*/
  if(ferror(datafile))
  {
   printf("Σφάλμα διαβάζοντας το αρχείο %s","Iris.dat");
   return 1;
  }
  i++;
 }
 /*Κλείσιμο αρχείου*/
 fclose(datafile);
 /*Δημιουργία πίνακα αποστάσεων*/
 k=0;
 /*Επιλέγοντας το πρώτο σημείο δεδομένων*/
 for(i=0;i<150;i++)
 {
  /*Επιλέγοντας το δεύτερο σημείο δεδομένων*/
  for(j=0;j<150;j++)
  {
   /*Υπολογισμός τετραγώνου απόστασης*/
   distance[i][j]=pow(lattice[i][1]-lattice[j][1],2)+pow(lattice[i][2]-lattice[j][2],2)+pow(lattice[i][3]-lattice[j][3],2)+pow(lattice[i][4]-lattice[j][4],2);
   /*Καταγραφή τετραγώνου απόστασης*/
   nearest[k][0]=distance[i][j];
   /*Καταγραφή των σημείων δεδομένων που το ορίζουν*/
   nearest[k][1]=i;
   nearest[k][2]=j;
   k++;
  }
 }
 /*Ταξινόμηση πίνακα τετραγώνων αποστάσεων βάσει αλγορίθμου φυσαλίδας*/
 for(i=22499;i>0;i--)
 {
  k=0;
  for(j=0;j<i;j++)
  {
   if(nearest[j][0]>nearest[j+1][0])
   {
    l=nearest[j][0];
    nearest[j][0]=nearest[j+1][0];
    nearest[j+1][0]=l;
    /*Ανταλλαγή ολόκληρης της εγγραφής*/
    l=nearest[j][1];
    nearest[j][1]=nearest[j+1][1];
    nearest[j+1][1]=l;
    l=nearest[j][2];
    nearest[j][2]=nearest[j+1][2];
    nearest[j+1][2]=l;
    k=1;
   }
  }
  /*Παύση μόλις ολοκληρωθεί η ταξινόμηση*/
  if(k==0)break;
 }
 /*Διατρέχοντας όλα τα σημεία δεδομένων*/
 for(i=0;i<150;i++)
 {
  /*Αρχικοποίηση αμοιβαίων γειτόνων και αντίστοιχων δεσμών με 150*/
  for(j=0;j<10;j++)
  {
   bond[i][j]=150;
  }
 }
 /*Διατρέχοντας όλα τα σημεία δεδομένων*/
 for(i=0;i<150;i++)
 {
  k=0;
  /*Διατρέχοντας τα ταξινομημένα τετράγωνα αποστάσεων*/
  for(j=0;j<22500;j++)
  {
   /*Έλεγχος εάν το πρώτο σημείο δεδομένων του αντίστοιχου τετραγώνου απόστασης είναι το επιλεγμένο και το δεύτερο δεν είναι το ίδιο*/
   if(nearest[j][1]==i&&nearest[j][0]!=0)
   {
    /*Καταγραφή πλησιέστερων γειτόνων επιλεγμένου σημείου δεδομένων*/
    neighbor[i][k]=nearest[j][2];
    k++;
   }
   /*Παύση μετά την καταγραφή του πέμπτου πλησιέστερου γείτονα*/
   if(k==5)break;
  }
 }
 n=0;
 /*Αρχικοποίηση μέσης τιμής αριθμού γειτόνων*/
 *average=0;
 /*Αρχικοποίηση διπλασίου τετραγώνου μέσης τιμής όλων των αποστάσεων μεταξύ γειτονικών ζευγών*/
 *local_length=0;
 /*Επιλέγοντας το πρώτο σημείο δεδομένων*/
 for(i=0;i<150;i++)
 {
  m=0;
  /*Επιλέγοντας το δεύτερο σημείο δεδομένων*/
  for(j=0;j<150;j++)
  {
   /*Διατρέχοντας τους πέντε πλησιέστερους γείτονες του δεύτερου σημείου δεδομένων*/
   for(k=0;k<5;k++)
   {
    /*Έλεγχος εάν ένας από αυτούς είναι το πρώτο σημείο δεδομένων*/
    if(i==neighbor[j][k])
    {
     /*Διατρέχοντας τους πέντε πλησιέστερους γείτονες του πρώτου σημείου δεδομένων*/
     for(l=0;l<5;l++)
     {
      /*Έλεγχος εάν ένας από αυτούς είναι το δεύτερο σημείο δεδομένων*/
      if(j==neighbor[i][l])
      {
       /*Ορισμός αμοιβαίου γείτονα*/
       bond[i][m]=j;
       /*Ανανέωση διπλασίου τετραγώνου μέσης τιμής όλων των αποστάσεων μεταξύ γειτονικών ζευγών*/
       *local_length+=sqrt(distance[i][j]);
       m++;
       n++;
      }
     }
    }
   }
  }
  /*Ανανέωση μέσης τιμής αριθμού γειτόνων*/
  *average+=m;
 }
 /*Κανονικοποίηση μέσης τιμής αριθμού γειτόνων*/
 *average/=150;
 /*Αρχικοποίηση διπλασίου τετραγώνου μέσης τιμής όλων των αποστάσεων μεταξύ γειτονικών ζευγών*/
 *local_length*=2**local_length/n;
 /*Είσοδος αρχικής θερμοκρασίας*/
 printf("Αρχική θερμοκρασία:");
 scanf("%lf",&temperature[0]);
 /*Είσοδος βήματος θερμοκρασίας*/
 printf("Βήμα θερμοκρασίας:");
 scanf("%lf",&step_temp);
 /*Είσοδος τελικής θερμοκρασίας*/
 printf("Τελική θερμοκρασία:");
 scanf("%lf",&final_temp);
 /*Υπολογισμός πλήθους θερμοκρασιών*/
 *num_temp=(final_temp-temperature[0])/step_temp;
 /*Επιβολή μέγιστης τιμής 100 για πλήθος θερμοκρασιών*/
 if(*num_temp>100)*num_temp=100;
 /*Υπολογισμός θερμοκρασιών*/
 for(i=1;i<*num_temp;i++)
 {
  temperature[i]=temperature[i-1]+step_temp;
 }
 return 0;
}
/*Συνάρτηση καθορισμού δεσμών του αλγορίθμου Swendsen-Wang*/
int bond_alg(int k,int bond[][10],int distance[][150],int lattice[][5],double average,double local_length,double temperature[])
{
 int i,j/*Μετρητές*/;

 /*Διατρέχοντας όλα τα σημεία δεδομένων*/
 for(i=0;i<150;i++)
 {
  /*Αρχικοποίηση όλων των δεσμών με μηδέν*/
  for(j=5;j<10;j++)
  {
   bond[i][j]=0;
  }
 }
 /*Διατρέχοντας όλα τα σημεία δεδομένων*/
 for(i=0;i<150;i++)
 {
  /*Διατρέχοντας όλους τους αμοιβαίους γείτονες*/
  for(j=0;j<5;j++)
  {
   /*Παύση εάν οι αμοιβαίοι γείτονες είναι λιγότεροι από πέντε*/
   if(bond[i][j]==150)break;
   /*Έλεγχος εάν δύο αμοιβαίοι γείτονες έχουν ίδια τιμή κατάστασης Potts*/
   if(lattice[i][0]==lattice[bond[i][j]][0])
   {
    /*Ορισμός αντίστοιχου δεσμού βάσει της παρακάτω πιθανότητας*/
    if(1-exp(-exp(-distance[i][bond[i][j]]/local_length)/average/temperature[k])>drand48())bond[i][j+5]=1;
   }
  }
 }
 return 0;
}
/*Αναδρομική συνάρτηση εύρεσης ομάδων*/
int cluster(int i,int new,int bond[][10],int flag[],int lattice[][5])
{
 int j/*Μετρητής*/;
 
 /*Έλεγχος εάν ο αλγόριθμος έχει<<επισκεφθεί>>ξανά το σημείο δεδομένων*/
 if(flag[i]!=1)
 {
  /*Σημείωση ώστε ο αλγόριθμος να μην<<επισκεφθεί>>ξανά το σημείο δεδομένων*/
  flag[i]=1;
  /*Αλλαγή τιμής κατάστασης Potts*/
  lattice[i][0]=new;
  /*Διατρέχοντας όλους του δεσμούς*/
  for(j=0;j<5;j++)
  {
   /*Έλεγχος εάν υπάρχει δεσμός και αναδρομή ώστε να αλλάξει τιμή κατάστασης Potts ολόκληρη ομάδα*/
   if(bond[i][j+5]==1)cluster(bond[i][j],new,bond,flag,lattice);
  }
 }
 return 0;
}
/*Συνάρτηση εξόδου διδιάστατης προβολής σε .ppm(Portable Pixel Map)αρχείο*/
int output(int lattice[][5],char filename[])
{
 FILE*pixmap=NULL/*Ορισμός αρχείου*/;
 int i,j/*Μετρητές*/,flower[80-40][70-10]/*Πίνακας προβολής πάνω στο επίπεδο που ορίζεται από το μήκος πετάλων και το μήκος σεπάλων*/;

 /*Άνοιγμα αρχείου*/
 pixmap=fopen(filename,"w");
 /*Έλεγχος έγκυρου ανοίγματος αρχείου*/
 if(!pixmap)
 {
  printf("Σφάλμα ανοίγοντας το αρχείο %s",filename);
  return 1;
 }
 /*Ορισμός αρχικής θέσης στην αρχή του αρχείου*/
 rewind(pixmap);
 /*Αρχικοποίηση του πίνακα διδιάστατης προβολής με μηδέν*/
 for(i=0;i<80-40;i++)
 {
  for(j=0;j<70-10;j++)
  {
   flower[i][j]=0;
  }
 }
 /*Απόδοση σε όλα τα σημεία δεδομένων της τιμής κατάστασης Potts τους*/
 for(i=0;i<150;i++)
 {
  flower[lattice[i][1]-40][lattice[i][3]-10]=lattice[i][0];
 }
 /*Δημιουργία απαραίτητης επικεφαλίδας αρχείου*/
 fprintf(pixmap,"P3 %d %d 100\n",70-10,80-40);
 /*Διατρέχοντας ολόκληρο τον πίνακα διδιάστατης προβολής*/
 for(i=0;i<80-40;i++)
 {
  for(j=0;j<70-10;j++)
  {
   /*Έλεγχος εάν είναι σημείο δεδομένων*/
   if(flower[i][j]==0)
   {
    /*Τύπωση στο αρχείο με μαύρο χρώμα*/
    fprintf(pixmap,"   %d   %d   %d",flower[i][j],flower[i][j],flower[i][j]);
   }
   /*Έλεγχος εάν η τιμή κατάστασης Potts είναι 100*/
   else if(flower[i][j]==100)
   {
    /*Τύπωση στο αρχείο με λευκό χρώμα*/
    fprintf(pixmap," %d %d %d",flower[i][j],flower[i][j],flower[i][j]);
   }
   /*Έλεγχος εάν η τιμή κατάστασης Potts είναι μικρότερη του 100 και μεγαλύτερη ή ίση του 75*/
   else if(flower[i][j]>=75&&flower[i][j]<100)
   {
    /*Τύπωση στο αρχείο σε γκρι απόχρωση*/
    fprintf(pixmap,"  %d  %d  %d",flower[i][j],flower[i][j],flower[i][j]);
   }
   /*Έλεγχος εάν η τιμή κατάστασης Potts είναι μικρότερη του 75 και μεγαλύτερη ή ίση του 50*/
   else if(flower[i][j]>=50&&flower[i][j]<75)
   {
    /*Τύπωση στο αρχείο σε κόκκινη απόχρωση*/
    fprintf(pixmap,"  %d   0   0",flower[i][j]);
   }
   /*Έλεγχος εάν η τιμή κατάστασης Potts είναι μικρότερη του 50 και μεγαλύτερη ή ίση του 25*/
   else if(flower[i][j]>=25&&flower[i][j]<50)
   {
    /*Τύπωση στο αρχείο σε πράσινη απόχρωση*/
    fprintf(pixmap,"   0  %d   0",flower[i][j]);
   }
   /*Έλεγχος εάν η τιμή κατάστασης Potts είναι μικρότερη του 25 και μεγαλύτερη ή ίση του 10*/
   else if(flower[i][j]>=10&&flower[i][j]<25)
   {
    /*Τύπωση στο αρχείο σε μπλε απόχρωση*/
    fprintf(pixmap,"   0   0  %d",flower[i][j]);
   }
   /*Εάν η τιμή κατάστασης Potts είναι μικρότερη του 10*/
   else
   {
    /*Τύπωση στο αρχείο σε μπλε απόχρωση*/
    fprintf(pixmap,"   0   0   %d",flower[i][j]);
   }
   /*Δημιουργία νέας γραμμής*/
   if(j==70-10-1)fprintf(pixmap,"\n");
  }
 }
 /*Κλείσιμο αρχείου*/
 fclose(pixmap);
 return 0;
}
/*Συνάρτηση αλγορίθμου Swendsen-Wang*/
int SW_alg(int num_temp,int steps,int bond[][10],int distance[][150],int lattice[][5],double average,double local_length,double temperature[])
{
 int i,j,k,l/*Μετρητές*/,max/*Μέγιστη τιμή*/,new/*Νέα τιμή κατάστασης Potts*/,flag[150]/*Πίνακας σημείων δεδομένων που έχει<<επισκεφθεί>>ο αλγόριθμος Swendsen-Wang*/,q[100]/*Πίνακας μετρητής τιμών καταστάσης Potts*/;
 double magnetization[100]/*Μαγνήτιση*/,magnetization2[100]/*Τετράγωνο μαγνήτισης*/,susceptibility[100]/*Πυκνότητα επιδεκτικότητας*/; 
 char key/*Κλειδί ελέγχου δημιουργίας διδιάστατων προβολών*/,filename[20]/*Όνομα αρχείου διδιάστατης προβολής*/;
 gnuplot_ctrl*a;

 /*Δυνατότητα επιλογής δημιουργίας διδιάστατων προβολών*/
 printf("Πιέστε y για να δημιουργηθούν διδιάστατες προβολές:");
 scanf("%s",&key);
 /*Διατρέχοντας όλες τις θερμοκρασίες*/
 for(k=0;k<num_temp;k++)
 {
  /*Αρχικοποίηση τιμής κατάστασης Potts όλων των σημείων δεδομένων*/
  for(i=0;i<150;i++)
  {
   lattice[i][0]=1;
  }
  /*Αρχικοποίηση μαγνήτισης*/
  magnetization[k]=0;
  /*Αρχικοποίηση τετραγώνου μαγνήτισης*/
  magnetization2[k]=0;
  /*Εκτελώντας M.C.S.*/
  for(j=0;j<steps;j++)
  {
   /*Διατρέχοντας όλα τα σημεία δεδομένων*/
   for(i=0;i<150;i++)
   {
    /*Αρχικοποίηση πίνακα σημείων δεδομένων που έχει<<επισκεφθεί>>ο αλγόριθμος Swendsen-Wang με μηδέν*/
    flag[i]=0;
   }
   /*Κλήση της συνάρτησης bond_alg*/
   bond_alg(k,bond,distance,lattice,average,local_length,temperature);
   /*Διατρέχοντας όλα τα σημεία δεδομένων για την εύρεση ομάδων*/
   for(i=0;i<150;i++)
   {
    /*Επιλογή νέας πιθανής τιμής κατάστασης Potts*/
    new=100*drand48()+1;
    /*Κλήση της συνάρτησης cluster*/
    cluster(i,new,bond,flag,lattice);
   }
   /*Αρχικοποίηση πίνακα μετρητή τιμών καταστάσης Potts με μηδέν*/
   for(i=0;i<100;i++)
   {
    q[i]=0;
   }
   /*Διατρέχοντας όλα τα σημεία δεδομένων*/
   for(i=0;i<150;i++)
   {
    /*Διατρέχοντας όλες τις πιθανές τιμές καταστάσης Potts μειωμένες*/
    for(l=0;l<100;l++)
    {
     /*Εύρεση τιμής κατάστασης Potts*/
     if(lattice[i][0]==l+1)
     {
      /*Καταμέτρηση τιμής κατάστασης Potts*/
      q[l]++;
      /*Παύση για επιλογή νέου σημείου δεδομένων*/
      break;
     }
    }
   }
   /*Εύρεση πολυπληθέστερης τιμής κατάστασης Potts*/
   i=1;
   max=q[0];
   while(i<100)
   {
    if(max<q[i])max=q[i];
    i++;
   }
   /*Υπολογισμός μαγνήτισης*/
   magnetization[k]+=(max/150.0*100-1)/99;
   /*Υπολογισμός τετραγώνου μαγνήτισης*/
   magnetization2[k]+=(max/150.0*100-1)/99*(max/150.0*100-1)/99;
  }
  /*Κανονικοποίηση μαγνήτισης*/
  magnetization[k]/=steps;
  /*Υπολογισμός τετραγώνου κανονικοποιημένης μαγνήτισης*/
  magnetization[k]*=magnetization[k];
  /*Κανονικοποίηση τετραγώνου μαγνήτισης*/
  magnetization2[k]/=steps;
  /*Υπολογισμός πυκνότητας επιδεκτικότητας*/
  susceptibility[k]=magnetization2[k]-magnetization[k];
  /*Αντιγραφή θερμοκρασίας*/
  sprintf(filename,"%f",temperature[k]);
  /*Έλεγχος επιλογής δημιουργίας διδιάστατων προβολών*/
  if(key=='y')
  {
   /*Ονομασία αρχείου διδιάστατης προβολής βάσει θερμοκρασίας*/
   strncat(filename,".ppm",4);
   /*Κλήση της συνάρτησης output*/
   if(output(lattice,filename)!=0)
   {
    printf("Ένα σφάλμα συνέβηκε όταν η συνάρτηση output κλήθηκε");
    return 1;
   }
  }
  /*Ένδειξη θερμοκρασίας ή αρχείου διδιάστατης προβολής εάν έχει δημιουργηθεί στη γραμμή εντολών*/
  printf("%s\n",filename);
 }
 /*Έλεγχος επιλογής δημιουργίας διδιάστατων προβολών*/
 if(key=='y')
 {
  /*Αντιστοίχιση στο είδος Iris Setosa τιμή κατάστασης Potts 74*/
  for(i=0;i<50;i++)
  {
   lattice[i][0]=74;
  }
  /*Αντιστοίχιση στο είδος Iris Versicolor τιμή κατάστασης Potts 49*/
  for(i=50;i<100;i++)
  {
   lattice[i][0]=49;
  }
  /*Αντιστοίχιση στο είδος Iris Virginica τιμή κατάστασης Potts 24*/
  for(i=100;i<150;i++)
  {
   lattice[i][0]=24;
  }
  /*Κλήση της συνάρτησης output για διδιάστατη προβολή επίσημης ταξινόμησης*/
  if(output(lattice,"Iris.ppm")!=0)
  {
   printf("Ένα σφάλμα συνέβηκε όταν η συνάρτηση output κλήθηκε");
   return 1;
  }
 }
 /*Παρουσίαση γραφικών σε συνεδρία gnuplot*/
 a=gnuplot_init();
 gnuplot_setstyle(a,"lines");
 gnuplot_set_xlabel(a,"Boltzmann constant*temperature");
 gnuplot_set_ylabel(a,"Susceptibility density");
 gnuplot_cmd(a,"set terminal svg");
 gnuplot_cmd(a,"set output \"Susceptibility.svg\"");
 gnuplot_plot_xy(a,temperature,susceptibility,num_temp,"");
 gnuplot_close(a);
 return 0;
}
/*Συνάρτηση main*/
int main()
{
 int num_temp/*Πλήθος θερμοκρασιών*/,steps/*M.C.S*/,bond[150][10]/*Πίνακας αμοιβαίων γειτόνων και αντίστοιχων δεσμών*/,distance[150][150]/*Πίνακας τετραγώνων αποστάσεων*/,lattice[150][5]/*Πίνακας τιμής κατάστασης Potts και τετραδιάστατων συντεταγμένων σημείων δεδομένων*/;
 double average/*Μέσης τιμή αριθμού γειτόνων*/,local_length/*Διπλάσιο τετράγωνο μέσης τιμής όλων των αποστάσεων μεταξύ γειτονικών ζευγών*/,temperature[100]/*Θερμοκρασίες*/;
 
 /*Κλήση της συνάρτησης input*/
 input(&num_temp,&steps,bond,distance,lattice,&average,&local_length,temperature);
 /*Κλήση της συνάρτησης SW_alg*/
 SW_alg(num_temp,steps,bond,distance,lattice,average,local_length,temperature);
 return 0;
}
